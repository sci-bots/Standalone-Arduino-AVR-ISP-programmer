#include "optiLoader.h"

const image_t PROGMEM image_328 = {
    // Sketch name, only used for serial printing
    {"optiboot_atmega328.hex"},
    // Chip name, only used for serial printing
    {"atmega328P"},
    // Signature bytes for 328P
    0x950F,
    // Programming fuses, written before writing to flash. Fuses set to
    // zero are untouched.
    {0x3F, 0xEF, 0xD4, 0xFD}, // {lock, low, high, extended}
    // Normal fuses, written after writing to flash (but before
    // verifying). Fuses set to zero are untouched.
    {0x0F, 0x0, 0x0, 0x0}, // {lock, low, high, extended}
    // Fuse verify mask. Any bits set to zero in these values are
    // ignored while verifying the fuses after writing them. All (and
    // only) bits that are unused for this atmega chip should be zero
    // here.
    {0x3F, 0xFF, 0xFF, 0xFF}, // {lock, low, high, extended}
    // size of chip flash in bytes
    32768,
    // size in bytes of flash page
    128,
    // The actual image to flash. This can be copy-pasted as-is from a
    // .hex file. If you do, replace all lines below starting with a
    // colon, but make sure to keep the start and end markers {R"( and
    // )"} in place.
    {R"(
:207C000033C0000052C0000050C000004EC000004CC000004AC0000048C0000046C000001D
:207C200044C0000042C0000040C000003EC000003CC000003AC0000038C0000036C000005C
:207C400087C1000032C0000030C000002EC000002CC000002AC0000028C0000026C0000068
:207C600025C0000022C0000011241FBECFEFD8E0DEBFCDBF14BEE0E6F0E088E18083108226
:207C800011E0A0E0B1E0E2EEFFE702C005900D92AA31B107D9F711E0AAE1B1E001C01D9256
:207CA000AE39B107E1F775D19AC1AACF1F920F920FB60F9211242F933F934F935F936F93DC
:207CC0008F939F93AF93BF93CF93DF93EF93FF938091B90090E0887F9070883A910509F43E
:207CE000D7C0893A910564F480389105D1F0803A910509F411C18036910509F017C10DC024
:207D0000803C910509F408C1883F910509F409C1883B910509F00AC1BEC010921B012C9A08
:207D2000FCC02091BB0040911B014130D9F0413020F0443008F045C035C0222329F023305C
:207D400038F481E080931B011092000190E404C081E280931A0190E020931A01992309F404
:207D60008FC091C080911A01813021F0823009F087C007C0203809F083C081E280931A0197
:207D80007FC080931B01222311F482E108C0213011F482E204C0223009F072C082E380938D
:207DA0001A010DC030E090919C0180E0282B392B30939D0120939C014F5F40931B0190E434
:207DC00062C080911A01823221F0823309F058C046C0E42FF0E0E85EFE4F2083433860F3DD
:207DE000C0919C01D0919D018CE7C030D80708F047C083E0FE0180935700E89507B600FC53
:207E0000FDCFAE01ACE1B1E061E08C9190E011963C91119720E0822B932B1296FA010C01C4
:207E200060935700E89511244E5F5F4FF1E0AC39BF0759F7C058DF4FD0939D01C0939C01E8
:207E4000C058D04085E0FE0180935700E89507B600FCFDCF81E180935700E89511C08091FF
:207E60009C0190919D0181BD92BD20BD019690939D0180939C01FA9AF99AF999FECF9CCF43
:207E800010921B0190E08091BC008068892B4CC010921B012C9A80911A018231A9F083318F
:207EA00018F4813029F406C08232D1F0823321F1EFEF2FC080911B01E82FF0E0EF5FFE4F6A
:207EC000E0818F5F8F7009C080911B01E82FF0E0EF5EFE4FE0818F5F877080931B0119C08F
:207EE000E0919C01F0919D013196F0939D01E0939C013197E4910DC080919C0190919D01E6
:207F000081BD92BDF89A019690939D0180939C01E0B5E093BB0001C02C988091BC00806C39
:207F200003C08091BC00806D8093BC00FF91EF91DF91CF91BF91AF919F918F916F915F9145
:207F40004F913F912F910F900FBE0F901F9018951F920F920FB60F9211248F939F938CE39A
:207F600086BD85B190E2892785B980910001823020F081508093000105C0813019F481E289
:207F800080931A019F918F910F900FBE0F901F90189580E384B92D9A91E095BF82E085BF2A
:207FA00085E085BD90936E0082E58093BA0085E48093BC00789480911A018132E1F7F894CE
:207FC0001092BC0010926E0015BC81E085BF15BE15B8E0E0F0E000003197E9F70995F894BB
:1C7FE000FFCF28545749424F4F546D3332387076322E311E950F807C0004000024
:00000001FF
    )"}
};

/*
 * Table of defined images. The first one matching the chip's signature
 * is used.
 */
const image_t *images[] = {
  &image_328,
};

uint8_t NUMIMAGES = sizeof(images)/sizeof(images[0]);
